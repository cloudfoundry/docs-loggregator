---
title:  Container Metrics
owner: 
---

This topic describes the metrics that are emitted by all containers managed by <%= vars.app_runtime_first %> and its scheduling system, Diego.

App metrics include the container metrics described below, plus any custom app metrics that developers create.

## <a id="container-metrics"></a> Diego Container Metrics

Diego containers emit the following resource usage metrics for their app instance (AI).  Each metric is averaged over and emitted every 15 seconds.

The following table describes all Diego container metrics:

<table id='container-metrics' class="nice" >
  <tr>
    <th width=20%>Metric</th>
    <th width=65%>Description</th>
    <th width=15%>Unit</th>
  </tr><tr>
    <td><code>CpuPercentage</code></td>
    <td>CPU time used by AI as a percentage of a single CPU core.<br><br>
    This is usually no greater than <code>100% * the number of vCPUs on the host Diego cell</code>, but it may be more due to discrepancies in measurement timing.</td>
    <td><code>float64</code></td>
  </tr><tr>
    <td><code>AbsoluteCPUEntitlement</code></td>
    <td>CPU time that the AI was entitled to use.<br><br>
    At minimum, the CPU time that a Diego cell provides an AI is <code>min(app memory, 8 GB) * (Diego cell vCPUs/Diego cell memory) * 100%</code>.<br><br>
    The platform operator can provide the Diego cell <code>vCPUs/memory</code> ratio to developers.<br>
    If a Diego cell is not at capacity or if other workloads on it are idle, the cell can provide more than the minimum CPU.</td>
    <td><code>uint64</code></td>
  </tr><tr>
    <td><code>AbsoluteCPUUsage</code></td>
    <td>CPU time used by AI.<br><br>
    <code>AbsoluteCPUUsage / AbsoluteCPUEntitlement</code> calculates a 0-100% range of AI usage per entitlement.</td>
    <td><code>uint64</code></td>
  </tr><tr>
    <td><code>MemoryBytes</code></td>
    <td>RAM memory used by AI, in MB.</td>
    <td><code>uint64</code></td>
  </tr><tr>
    <td><code>MemoryBytesQuota</code></td>
    <td>RAM memory available, in GB.</td>
    <td><code>uint64</code></td>
  </tr><tr>
    <td><code>DiskBytes</code></td>
    <td>Disk space used by AI, in MB.</td>
    <td><code>uint64</code></td>
  </tr><tr>
    <td><code>DiskBytesQuota</code></td>
    <td>Disk space available, in GB.</td>
    <td><code>uint64</code></td>
  </tr><tr>
    <td><code>ContainerAge</code></td>
    <td>Age of container, in nanoseconds.</td>
    <td><code>uint64</code></td>
  </tr>
</table>

**Loggregator v1**: Most of the container metrics are emitted in a `ContainerMetric` envelope.
The `AbsoluteCPUEntitlement`, `AbsoluteCPUUsage`, and `ContainerAge` container metrics are emitted
as separate `ValueMetric` envelopes.

**Loggregator v2**: All container metrics are emitted in gauge envelopes. The
`AbsoluteCPUEntitlement`, `AbsoluteCPUUsage`, and `ContainerAge` container metrics are emitted in a
separate envelope to the other container metrics.

## <a id="cf-cli"></a> Retrieve Container Metrics from the cf CLI

You can use Cloud Foundry command-line interface (cf CLI) commands to return container metrics.

### <a id="cf-app"></a> Retrieve CPU, Memory, and Disk Metrics

To retrieve CPU, memory, and disk metrics for all instances of an app:

1. Run the command `cf app APP-NAME`.

The command output lists Diego container metric values as follows:

| Label in Output | Metrics listed, as described in [Diego Container Metrics](#container-metrics), above |
|---|---|
| `cpu` | `CpuPercentage` |
| `memory` | `MemoryBytes` of `MemoryBytesQuota` |
| `disk` | `DiskBytes` of `DiskBytesQuota` |

For example:

<pre class="terminal">
$ cf app dora-example
Showing health and status for app dora-example in org o / space s as admin...

name:              dora-example
requested state:   started
routes:            dora-example.bosh-lite.com
last uploaded:     Fri 05 Apr 10:41:21 PDT 2019
stack:             cflinuxfs3
buildpacks:        ruby

type:           web
instances:      1/1
memory usage:   256M
     state     since                  cpu    memory          disk          details
#0   running   2019-04-05T17:41:31Z   0.4%   39.5M of 256M   89.9M of 1G
</pre>

Using the `cf app` command for your application will show you what percentage of CPU the app is currently using relative to the total CPU on the host machine.

Imagine there are 3 cores on the Diego cell where your application is deployed to. That results in 300% CPU that will be distributed between all the applications on the cell, and this is the percentage that the `cf app` command displays. So the metrics depend on factors like the capacity of the Diego cell and the total number of applications on it that are not visible to the user, which makes it hard for users and operators to balance CPU resources.

On a standard system, you can expect always to be able to get 100% of your CPU no matter what other applications are on the cell. If there are spare resources on the machine you will be allowed to consume over 100% CPU.

Let’s see the spare resources are distributed on the Diego cell. Assume your well-behaved application that consumes less than its entitlement most of the time. Since you are behaving so well you expect to get the maximum amount of spare CPU resources, but without the CPU entitlement feature free depends on your neighbors (the apps running on the same Diego cell as you are). If the other apps constantly use high CPU, they restrict other apps like yours to occasionally use more CPU when needed. Even though the other apps on the same Diego cell usually use way more CPU than they are entitled to when your app needs extra CPU the spare capacity is being distributed evenly between all the other apps and you. This means you will never be able to spike over a certain amount of CPU. In order to provide the bandwith to occasionally, operators may overprovision resources for Diego cells.

### <a id="cf-app"></a> CPU Entitlement

[CPU Entitlements in Cloud Foundry](https://www.youtube.com/watch?v=vV87xmxKLeA)

CPU entitlement describes the percentage of host CPU a particular application instance is ‘entitled’ to use. Users will see CPU performance of less than 100% when their usage is within their entitlement and greater than 100% when they are above their entitlement.

### <a id="cf-app"></a> Retrieve CPU Entitlement Metrics (Experimental)

The new metric shows the amount of CPU usage relative to your entitlement. The amount of CPU an application is entitled to (in Cloud Foundry) is set proportionally to the amount of memory that the application has. For example, an application with access to 256MB of memory on a 512MB machine has access to half of the memory on the machine and is also entitled to half of the CPU of that machine. 

This plugin allows Cloud Foundry application developers to make better decisions about scaling applications and initial resource allocation of applications.

To see app instance `AbsoluteCPUEntitlement` metrics from the command line:

1. Install the CPU Entitlement Plugin from [cpu-entitlement-plugin](https://github.com/cloudfoundry/cpu-entitlement-plugin) in GitHub.

2. Run the command `cf cpu-entitlement APP-NAME`.

For example:

<pre class="terminal">
$ cf cpu-entitlement dora-example
Note: This feature is experimental.
Showing CPU usage against entitlement for app dora-example in org example-org / space example-org-staging as dora@example.com ...
​
     avg usage   curr usage
#0   1.62%       1.66%
#1   2.93%       3.09%
#2   2.51%       2.62%
​
</pre>

This property is currently used to calculate CPU entitlement for metric purposes and for triggering moving between bad/good cgroups and its calculation currently is:
entitlement = bundle.Resources.CPU.Shares * cpuEntitlementPerShare * containerAgeNanos / 100.0

To enable the CPU entitlement plugin, the field [experimental_cpu_throttling](https://github.com/cloudfoundry/garden-runc-release/blob/9d9826d08b72c0d8b7a7d968b1311047039be08c/jobs/garden/spec#L225-L227) should be set to true by using this [operation](https://github.com/cloudfoundry/cf-deployment/blob/main/operations/enable-cpu-throttling.yml#L4)

The exact mapping from memory to CPU is determined by the platform operator through a bosh release property on the garden release called [experimental_cpu_entitlement_per_share_in_percent](https://github.com/cloudfoundry/garden-runc-release/blob/9d9826d08b72c0d8b7a7d968b1311047039be08c/jobs/garden/spec#L165-L167).

### <a id="cf-app"></a> Throttling

Current versions of Cloud Foundry allow applications to use more CPU than they are entitled to if CPU time is available at that moment, regardless of how the application has behaved in the past. This behavior will change in the future; applications will still be allowed to temporarily exceed their entitlement, but preference will be given to those applications that have been using less than their entitlement over a rolling window of time. Applications will never be forced below their entitlement.

When using the `cf cpu-entitlement` command you see 2 values - average and current usage. The avarage usage is used to split the application into 2 groups - good and bad. Good applications are the ones that have their average CPU usage below 100% and the bad ones have it over 100%.

Both good and bad application always get their entitlement. The difference is in how the spare CPU gets distributed between them. All the spare CPU will be given to the good application that needs it and the bad apps will get throttled to only what they are entitled to.

If the CPU spike of a good app is for a long period of time then it will eventually become a bad app and therefore will be throttled to a 100% if a different good app needs the CPU. This way resources get distributed more fairly between applications.

### <a id="cf-app"></a> The CPU overentitlement plugin

The plugin shows when your app has been throttled which helps you forecast when to upscale.

You can check all the so called bad applications in your organization by using the CPU overentitlement plugin and the `cf oei` command.

1. Install the CPU Overentitlement Plugin from [cpu-entitlement-plugin](https://github.com/cloudfoundry/cpu-entitlement-plugin) in GitHub.

2. Run the command `cf oei`.

For example:

<pre class="terminal">
$ cf cpu-entitlement dora-example
Note: This feature is experimental.
Showing over-entitlement apps in org example-org / space example-org-staging as dora@example.com ...
​
     space                     app
#0   example-org-staging       dora-example-2     
#1   example-org-staging       dora-example-3
#2   example-org-staging       dora-example-4
​
</pre>

Entitlement is adjusted when [cpu-entitlement-per-share](https://github.com/cloudfoundry/garden-runc-release/blob/9d9826d08b72c0d8b7a7d968b1311047039be08c/jobs/garden/spec#L165-L167) is modified in the garden config. When a container is throttled, we would expect it to be assigned a share matching its 100% entitlement (rather than currently where the weighting is just based on its weight). This is 100% entitlement when cpu-entitlement-per-share is not modified, but not if the value is modified. 
For example, set cpu-entitlement-per-share to half the default value for the cell, and successfully throttled apps will show 200% current entitlement usage.
